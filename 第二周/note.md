#### 对所有权、不可变引用、可变引用这三者的规则或特性做一个集中的总结：

**固定字节数类型与动态字节数类型**

+ 对于固定字节数类型如u32，会默认放在**栈**上；

+ 对于动态字节类型如**字符串**，会默认放在**堆**上；

堆上资源会被栈上用一个局部变量指向，也就是**栈帧联系了堆** （RAII）。

Rust中对动态字节数类型，对**变量再赋值上**，还做了别的事情：

+ 所有权move：栈帧中，把指向堆字符串的引用由s1拷贝到了s2，但**还抹去了原来s1到堆字符串的引用。** 即**任意时间某资源有且只有一个所有者**

总结：

可以看出使用到堆中的资源会变复杂，**涉及栈指向（绑定）堆的一般用引用**，只用到小资源**栈的一般就完全拷贝（新值新所有者）**。

**默认做复制**操作的有（小资源）:

+ 所有的整数类型，比如u32

+ 布尔类型，bool

+ 浮点数类型:f32,f64

+ 字符类型 char

+ **由以上类型组成的元组**类型 Tuple，如 (i32,i32,char)其它类型，默认都是做值的移动操作。

除了上述情况，其他类型默认做值的move操作。

# 所有权

Rust世界从所有权基础是**三条定义**出发：

- Rsut中，每一个资源都有一个所有者

- 任一时刻，一个资源只有一个所有者

- 所有者所在作用域结束时，**资源会被释放**

所有者：以**变量名**来表示。

作用域：变量有效的区间，一对花括号中，从**变量创建开始到花括号结束**的地方。

# 不可变引用 &x

```rust
fn foo(s:String) {
    println!("{s}");
}
fn main() {
    let s1=String::from("I am a superman.");
    foo(s1);//实际上在这一步里的函数结束时，s1就被回收掉了
    println!("(s1)");//这里编译失败 因为替身使者s上位后被系统回收，回不去s1了。
}
```

“引用 &“在rust中，从语义层面来看实际上是“**借用**”，即把所有权从人家那里借来。

传址引用就是借用，当借用的东西被系统回收了，所有权会物归原主。可以理解为rust内置法庭把东西判回给真主人。

```rust
fn main() {
        let a = 10u32;
        let b = &a;
        let c = &&&&&a;
        let d = &b;
        let e = b;
        println!("{a}");
        println!("{b}");
        println!("{c}");
        println!("{d}");
        println!("{e}");
}
```

//报错：无 //输出：全是10

总结：**rust更关注人类的业务**，认为程序员**只会用一个&**，因此多个&也会被识别为1个，不存在多重引用。

语义层面上看，就是只要引用最终指向的那个值。

由于引用也是一种值变量，因此赋值的时候也是做**引用拷贝**的，而不是move和引用指向的值拷贝。

概念区分：引用、值、移动

+ 引用指向了值，**引用本身也是值**。

+ 转移是把所有权也移动了，但是引用拷贝实际上是完全拷贝，但最终都是指向同一个值。

# 可变引用 &mut x



```rust
fn main() {
let a=10u32;
let b =&mut a;
*b=20;
println!("{b)");  }

```

变量赋值可变引用后，用*（解引用符号）给变量开个锁就能修改值了。



可以想象一下，

不可变变量是家里的一个被焊死的箱子，改变不了里面的东西。

可变变量是家里的一个上锁的箱子，主人用*这把钥匙就能开锁，对内部进行改变。

项目结构是否也是类似院子、家、主人这种结构?可以用日常生活把这些结构都形象地形容出来吗。



像函数中foo(&mut x){}这样&mut作为参数的话，从语义上理解就是把变量借给参数，在其函数作用域结束后就会物归原主。被回收的只有函数中的东西，而所有权则回归。



#### 引用存在一个scope特性，**可变引用与不可变引用的生存范围不能重叠。**

```rust
fn main() {
let a=10u32;
let b =&mut a;
*b=20;
println!("{a)");  
println!("{b)");  
//编译失败
}
```

原因：b从创建到被回收，属于可变引用生存范围，其中**a在其里面属于不可变引用**，因为重叠了所以编译失败



总结：

+ rust中的引用必定有效

+ 可变引用与不可变引用的作用域不能重叠overlap

+ 某时某刻一个资源只能存在一个可变引用

+ 一个资源的不可变引用可以存在多个

rust的目标就是内存安全，对于修改内存的东西原则上只存在一个，不修改内存想几个就几个。修改内存的事情单独做（独自作用域），不要牵扯到别的。



+ 不可变引用可以被复制

+ 可变引用只能被move
